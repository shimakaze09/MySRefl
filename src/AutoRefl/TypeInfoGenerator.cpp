//
// Created by Admin on 26/03/2025.
//

#include "TypeInfoGenerator.h"

#include <sstream>

using namespace My::MySRefl;
using namespace std;

string TypeInfoGenerator::Generate(const vector<TypeMeta>& typeMetas) {
  stringstream ss;

  constexpr auto indent = "    ";

  ss << "// This file is generated by Ubpa::USRefl::AutoRefl" << endl
     << endl
     << "#pragma once" << endl
     << endl
     << "#include <USRefl/USRefl.h>" << endl
     << endl;

  for (const auto& typeMeta : typeMetas) {
    const auto fullname = typeMeta.GenerateFullName();
    const std::string tname = typeMeta.IsTemplateType() ? fullname : "Type";
    ss << "template<" << typeMeta.GenerateTemplateList() << ">" << endl
       << "struct Ubpa::USRefl::TypeInfo<" << fullname << ">" << endl;

    ss << indent << ": TypeInfoBase<" << fullname;
    auto publicBaseIndice = typeMeta.GetPublicBaseIndices();
    if (!publicBaseIndice.empty()) {
      if (publicBaseIndice.size() > 1) {
        ss << "," << endl;
        for (size_t i = 0; i < publicBaseIndice.size(); i++) {
          const auto& base = typeMeta.bases[publicBaseIndice[i]];
          ss << indent << indent << base.GenerateText();
          if (i != publicBaseIndice.size() - 1)
            ss << ",";
          ss << endl;
        }
        ss << indent;
      } else
        ss << ", " << typeMeta.bases.front().GenerateText();
    }

    ss << ">" << endl << "{" << endl;

    // name
    ss << "#ifdef UBPA_USREFL_NOT_USE_NAMEOF" << endl;

    if (typeMeta.IsTemplateType())
      ss << indent << "// [!] all instance types have the same name" << endl;

    ss << indent << "static constexpr char name[" << (typeMeta.name.size() + 1)
       << "] = \"" << typeMeta.name << "\";" << endl
       << "#endif" << endl;

    // attributes
    switch (config.attrListConstMode) {
      case Config::ConstMode::Constepxr:
        ss << indent << "static constexpr AttrList attrs = {";
        break;
      case Config::ConstMode::Const:
        ss << indent << "inline static const AttrList attrs = {";
        break;
      case Config::ConstMode::NonConst:
        ss << indent << "inline static AttrList attrs = {";
        break;
    }
    if (!typeMeta.attrs.empty()) {
      ss << endl;
      for (const auto& attr : typeMeta.attrs) {
        auto name = attr.GenerateName(
            attr.ns.empty() ? config.nonNamespaceAttrNameWithoutQuotation
                            : !config.namespaceAttrNameWithQuotation);
        ss << indent << indent << "Attr {" << name;
        if (!attr.value.empty())
          ss << ", " << attr.GenerateValue(config.isAttrValueToFunction);
        ss << "}," << endl;
      }
      ss << indent;
    }
    ss << "};" << endl;

    // fields
    switch (config.attrListConstMode) {
      case Config::ConstMode::Constepxr:
        ss << indent << "static constexpr FieldList fields = {";
        break;
      case Config::ConstMode::Const:
        ss << indent << "inline static const FieldList fields = {";
        break;
      case Config::ConstMode::NonConst:
        ss << indent << "inline static FieldList fields = {";
        break;
    }
    if (!typeMeta.fields.empty()) {
      ss << endl;
      for (const auto& field : typeMeta.fields) {
        if (field.isTemplate)
          continue;

        ss << indent << indent << "Field {\"";
        // name
        ss << field.name << "\", ";
        // value
        switch (field.mode) {
          case Field::Mode::Variable: {
            ss << "&" << tname << "::" << field.name;
            break;
          }
          case Field::Mode::Function: {
            // TODO
            // - overload
            // - default value function overload
            // - constructor
            // - destructor
            // - operator
            if (typeMeta.IsOverloaded(field.name))
              ss << "static_cast<" << field.GenerateFunctionType("Type")
                 << ">(&Type::" << field.name << ")";
            else
              ss << "&" << tname << "::" << field.name;
            break;
          }
          case Field::Mode::Value: {
            ss << tname << "::" << field.name;
            break;
          }
        }
        // attributes
        if (!field.attrs.empty() || field.mode != Field::Mode::Value &&
                                        config.isInitializerAsAttr &&
                                        !field.initializer.empty()) {
          ss << "," << endl
             << indent << indent << indent << "AttrList {" << endl;
          if (config.isInitializerAsAttr && !field.initializer.empty()) {
            Attr attr;
            attr.name = config.name_initializer;
            attr.ns = config.ns_initializer;
            attr.value = field.initializer;
            auto name = attr.GenerateName(
                attr.ns.empty() ? config.nonNamespaceAttrNameWithoutQuotation
                                : !config.namespaceAttrNameWithQuotation);
            ss << indent << indent << indent << indent << "Attr {" << name
               << ", "
               << attr.GenerateValue(field.GenerateSimpleFieldType(),
                                     config.isInitializerToFunction)
               << "}," << endl;
          }
          for (const auto& attr : field.attrs) {
            auto name = attr.GenerateName(
                attr.ns.empty() ? config.nonNamespaceAttrNameWithoutQuotation
                                : !config.namespaceAttrNameWithQuotation);
            ss << indent << indent << indent << indent << "Attr {" << name;
            if (!attr.value.empty())
              ss << ", " << attr.GenerateValue(config.isAttrValueToFunction);
            ss << "}," << endl;
          }
          ss << indent << indent << indent << "}" << endl << indent << indent;
        }
        ss << "}," << endl;
      }
      ss << indent;
    }
    ss << "};" << endl;  // end of fields

    ss << "};" << endl << endl;  // end of TypeInfo
  }

  return ss.str();
}
