//
// Created by Admin on 12/03/2025.
//

#include "AutoRefl.h"

#include <MyANTLR/ParserCpp14/CPP14Lexer.h>
#include <MyANTLR/ParserCpp14/CPP14Parser.h>

#include <iostream>
#include <sstream>

using namespace My::MySRefl;
using namespace std;
using namespace antlr4;

string AutoRefl::Parse(string_view code) {
  // [ 1. clear ]
  typeInfos.clear();
  curNamespace.clear();
  curMetas = nullptr;
  curTypeInfo = nullptr;
  curVarInfo = nullptr;
  curAccessSpecifier = AccessSpecifier::PRIVATE;

  // [2. parse]
  ANTLRInputStream input(code.data());
  CPP14Lexer lexer(&input);
  CommonTokenStream tokens(&lexer);

  CPP14Parser parser(&tokens);
  tree::ParseTree* tree = parser.translationunit();

  tree->accept(this);

  // [3. generate]
  stringstream ss;
  const string indent = "    ";

  ss << "// This file is generated by My::MySRefl::AutoRefl" << endl
     << endl
     << "#pragma once" << endl
     << endl
     << "#include <MySRefl/MySRefl.h>" << endl
     << endl;

  for (const auto& typeinfo : typeInfos) {
    string ns;
    for (auto a_ns : typeinfo.ns) ns += a_ns + "::";
    string type = ns + typeinfo.name;
    /*string codetype;
    for (size_t i = 0; i < type.size(); i++) {
            if (type[i] == ':') {
                    codetype += "_";
                    i++;
            }
            else
                    codetype += type[i];
    }*/

    ss << "template<>" << endl
       << "struct My::MySRefl::TypeInfo<" << type << ">" << endl
       << indent << ": My::MySRefl::TypeInfoBase<" << type << ">" << endl
       << "{" << endl;

    // type attrs
    ss << indent << "static constexpr AttrList attrs = {" << endl;
    for (const auto& [key, value] : typeinfo.metas) {
      ss << indent << indent << "Attr {" << "\"" << key << "\""
         << (value.empty() ? "" : (", " + value)) << " }, " << endl;
    }
    ss << indent << "};" << endl;  // end AttrList

    // field
    ss << indent << "static constexpr FieldList fields = {" << endl;
    // var
    for (const auto& varInfo : typeinfo.varInfos) {
      if (varInfo.access != AccessSpecifier::PUBLIC) continue;

      ss << indent << indent << "Field {"
         << "\"" << varInfo.name << "\", "
         << "&" << type << "::" << varInfo.name;

      if (!varInfo.metas.empty()) {
        ss << "," << endl << indent << indent << indent << "AttrList {" << endl;
        for (const auto& [key, value] : varInfo.metas) {
          ss << indent << indent << indent << indent << "Attr {" << "\"" << key
             << "\"" << (value.empty() ? "" : (", " + value)) << " }, " << endl;
        }
        ss << indent << indent << indent << "}" << endl;  // end AttrList
      }

      ss << indent << indent << "}," << endl;
    }
    // func
    for (const auto& funcInfo : typeinfo.funcInfos) {
      if (funcInfo.access != AccessSpecifier::PUBLIC) continue;

      ss << indent << indent << "Field {"
         << "\"" << funcInfo.name << "\", "
         << "&" << type << "::" << funcInfo.name;

      if (!funcInfo.metas.empty()) {
        ss << "," << endl << indent << indent << indent << "AttrList {" << endl;
        for (const auto& [key, value] : funcInfo.metas) {
          ss << indent << indent << indent << indent << "Attr {" << "\"" << key
             << "\"" << (value.empty() ? "" : (", " + value)) << " }, " << endl;
        }
        ss << indent << indent << indent << "}" << endl;  // end AttrList
      }

      ss << indent << indent << "}," << endl;
    }
    ss << indent << "};" << endl;  // end FieldList

    ss << "};" << endl;  // end TypeInfo
  }

  return ss.str();
}

antlrcpp::Any AutoRefl::visitOriginalnamespacedefinition(
    CPP14Parser::OriginalnamespacedefinitionContext* ctx) {
  curNamespace.push_back(ctx->Identifier()->getText());
  auto result = visitChildren(ctx);
  curNamespace.pop_back();
  return result;
}

antlrcpp::Any AutoRefl::visitClassspecifier(
    CPP14Parser::ClassspecifierContext* ctx) {
  typeInfos.emplace_back();
  curTypeInfo = &typeInfos.back();
  curTypeInfo->ns = curNamespace;
  auto result = visitChildren(ctx);
  curTypeInfo = nullptr;
  return result;
}

antlrcpp::Any AutoRefl::visitClasshead(CPP14Parser::ClassheadContext* ctx) {
  curMetas = &curTypeInfo->metas;
  auto result = visitChildren(ctx);
  curMetas = nullptr;
  return result;
}

antlrcpp::Any AutoRefl::visitClasskey(CPP14Parser::ClasskeyContext* ctx) {
  curTypeInfo->classkey = ctx->getText();
  if (curTypeInfo->classkey == "struct")
    curAccessSpecifier = AccessSpecifier::PUBLIC;
  else
    curAccessSpecifier = AccessSpecifier::PRIVATE;

  return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitClassname(CPP14Parser::ClassnameContext* ctx) {
  curTypeInfo->name = ctx->getText();
  return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitAttribute(CPP14Parser::AttributeContext* ctx) {
  if (curMetas) {
    auto argCtx = ctx->attributeargumentclause();
    string arg = argCtx ? argCtx->balancedtokenseq()->getText() : "";
    curMetas->emplace(ctx->attributetoken()->getText(), move(arg));
  }
  return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitAccessspecifier(
    CPP14Parser::AccessspecifierContext* ctx) {
  auto accessStr = ctx->getText();
  if (accessStr == "public")
    curAccessSpecifier = AccessSpecifier::PUBLIC;
  else if (accessStr == "protected")
    curAccessSpecifier = AccessSpecifier::PROTECTED;
  else
    curAccessSpecifier = AccessSpecifier::PRIVATE;
  return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitMemberdeclaration(
    CPP14Parser::MemberdeclarationContext* ctx) {
  if (ctx->usingdeclaration() || ctx->static_assertdeclaration() ||
      ctx->templatedeclaration() || ctx->aliasdeclaration() ||
      ctx->emptydeclaration())
    return {};

  curFieldInfo.access = curAccessSpecifier;
  curMetas = &curFieldInfo.metas;
  inMember = true;

  auto result = visitChildren(ctx);

  if (curFieldInfo.isFunc) {
    curFuncInfo->metas = move(curFieldInfo.metas);
    curFuncInfo->name = move(curFieldInfo.name);
    curFuncInfo->access = curFieldInfo.access;
  } else {
    curVarInfo->metas = move(curFieldInfo.metas);
    curVarInfo->name = move(curFieldInfo.name);
    curVarInfo->access = curFieldInfo.access;
  }

  curVarInfo = nullptr;
  curFuncInfo = nullptr;
  curFieldInfo.metas.clear();
  curFieldInfo.name.clear();
  inMember = false;
  curMetas = nullptr;

  return result;
}

antlrcpp::Any AutoRefl::visitNoptrdeclarator(
    CPP14Parser::NoptrdeclaratorContext* ctx) {
  if (!inMember) return {};

  // not the first time to visit noptrdeclarator
  if (curFuncInfo != nullptr || curVarInfo != nullptr)
    return visitChildren(ctx);

  curFieldInfo.isFunc = ctx->parametersandqualifiers() != nullptr;

  if (curFieldInfo.isFunc) {
    curTypeInfo->funcInfos.emplace_back();
    curFuncInfo = &curTypeInfo->funcInfos.back();
  } else {
    curTypeInfo->varInfos.emplace_back();
    curVarInfo = &curTypeInfo->varInfos.back();
  }

  return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitParametersandqualifiers(
    CPP14Parser::ParametersandqualifiersContext* ctx) {
  return {};  // jump
              // return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitDeclspecifier(
    CPP14Parser::DeclspecifierContext* ctx) {
  if (!inMember) return visitChildren(ctx);

  if (curFieldInfo.isFunc) return {};  // TODO

  if (!ctx->typespecifier()) curVarInfo->specifiers.push_back(ctx->getText());

  return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitUnqualifiedid(
    CPP14Parser::UnqualifiedidContext* ctx) {
  if (!inMember) return {};
  curFieldInfo.name = ctx->getText();

  return {};
  // return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitFunctionbody(
    CPP14Parser::FunctionbodyContext* ctx) {
  return {};  // jump
              // return visitChildren(ctx);
}
